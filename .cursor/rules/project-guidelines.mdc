
# GN-Indexer 프로젝트 코딩 가이드라인

## 📋 기본 원칙

### 1. 주석 작성 규칙
- **모든 주석은 영어로 작성**
- 직관적이고 명확한 설명 제공
- 함수, 구조체, 중요한 로직에 주석 필수

### 2. 패키지 구조 규칙
```
internal/
├── client/                 # 외부 API 통신 (HTTP, WebSocket)
├── producer/               # Producer 로직 (블록 동기화)
├── consumer/               # Consumer 로직 (이벤트 처리)
├── types/                  # 공통 타입 정의
├── service/                # 비즈니스 로직 서비스
├── domain/                 # 도메인 모델
├── repository/             # 데이터 접근 계층
├── queue/                  # 메시지 큐 처리
├── api/                    # API 관련
└── config/                 # 설정 관리
```

### 3. MSA 아키텍처 패턴
- **Producer**: `client/` → `producer/` → `service/` → `repository/`
- **Consumer**: `queue/` → `consumer/` → `service/` → `repository/`
- **API**: `api/` → `service/` → `repository/`

## 🏗️ 코드 구조 가이드라인

### 1. 파일 및 패키지 명명
- **파일명**: snake_case 사용 (예: `event_parser.go`, `http_client.go`)
- **패키지명**: 소문자 단일 단어 사용 (예: `client`, `producer`, `consumer`)
- **구조체명**: PascalCase 사용 (예: `SubscriptionClient`, `EventParser`)

### 2. 함수 작성 규칙
```go
// FunctionName performs a specific action
// Parameters: description of parameters
// Returns: description of return values
func FunctionName(ctx context.Context, param string) error {
    // Implementation with clear logic
    if err := doSomething(); err != nil {
        return fmt.Errorf("context: %w", err)
    }
    return nil
}
```

### 3. 에러 처리
- **항상 에러를 체크하고 적절히 처리**
- **fmt.Errorf로 컨텍스트 정보 추가**
- **로그 메시지와 함께 에러 정보 제공**

```go
if err := someOperation(); err != nil {
    log.Printf("operation failed: %v", err)
    return fmt.Errorf("operation failed: %w", err)
}
```

### 4. 로깅 규칙
- **구조화된 로그 메시지 사용**
- **중요한 단계마다 로그 추가**
- **에러 상황에서 상세한 정보 제공**

```go
log.Printf("ServiceName: starting operation for %s", identifier)
log.Printf("ServiceName: operation completed successfully")
log.Printf("ServiceName: operation failed: %v", err)
```

## 🔧 특정 패키지 가이드라인

### 1. Client 패키지 (`internal/client/`)
- **HTTP/WebSocket 클라이언트 구현**
- **재사용 가능한 인터페이스 제공**
- **연결 관리 및 에러 핸들링**

### 2. Producer 패키지 (`internal/producer/`)
- **블록 동기화 핵심 로직**
- **데이터 수집 및 처리**
- **실시간 동기화 지원**

### 3. Consumer 패키지 (`internal/consumer/`)
- **이벤트 처리 및 파싱**
- **비즈니스 로직 구현**
- **큐 메시지 소비**

### 4. Service 패키지 (`internal/service/`)
- **여러 컴포넌트 조합**
- **비즈니스 로직 오케스트레이션**
- **트랜잭션 관리**

### 5. Repository 패키지 (`internal/repository/`)
- **데이터베이스 접근 로직**
- **CRUD 작업 구현**
- **데이터 무결성 보장**

## 📝 코드 예시

### 1. 구조체 정의
```go
// ServiceName handles specific business logic
type ServiceName struct {
    client     *client.Client
    repository repository.Repository
    config     *config.Config
}

// NewServiceName creates a new service instance
func NewServiceName(client *client.Client, repo repository.Repository, cfg *config.Config) *ServiceName {
    return &ServiceName{
        client:     client,
        repository: repo,
        config:     cfg,
    }
}
```

### 2. 메서드 구현
```go
// ProcessData processes incoming data
func (s *ServiceName) ProcessData(ctx context.Context, data *domain.Data) error {
    log.Printf("ServiceName: processing data %s", data.ID)
    
    // Validate input
    if err := s.validateData(data); err != nil {
        return fmt.Errorf("validate data: %w", err)
    }
    
    // Process data
    if err := s.repository.Save(ctx, data); err != nil {
        return fmt.Errorf("save data: %w", err)
    }
    
    log.Printf("ServiceName: data %s processed successfully", data.ID)
    return nil
}
```

### 3. 에러 처리
```go
// HandleError handles errors with proper context
func (s *ServiceName) HandleError(err error, operation string) error {
    if err == nil {
        return nil
    }
    
    log.Printf("ServiceName: %s failed: %v", operation, err)
    return fmt.Errorf("%s: %w", operation, err)
}
```

## 🚀 성능 및 안정성 가이드라인

### 1. 컨텍스트 사용
- **모든 외부 호출에 context 사용**
- **타임아웃 및 취소 처리**
- **리소스 정리 보장**

### 2. 동시성 처리
- **고루틴 사용 시 적절한 동기화**
- **채널 사용으로 안전한 통신**
- **데드락 방지**

### 3. 리소스 관리
- **연결 풀 사용**
- **메모리 누수 방지**
- **적절한 정리 로직**

## 🔍 코드 리뷰 체크리스트

- [ ] 주석이 영어로 작성되었는가?
- [ ] 에러 처리가 적절한가?
- [ ] 로그 메시지가 명확한가?
- [ ] 패키지 구조가 올바른가?
- [ ] 함수명이 명확한가?
- [ ] 컨텍스트가 적절히 사용되었는가?
- [ ] 테스트 코드가 있는가?

## 📚 참고 자료

- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Effective Go](https://golang.org/doc/effective_go.html)
- [Go Best Practices](https://github.com/golang-standards/project-layout)

- 데이터 무결성 검사는 실시간 동기화가 안정화된 후 실행
- 무결성 검사 결과 누락된 데이터가 있으면 자동으로 복구되어 완벽한 데이터셋 구성