
# GN-Indexer í”„ë¡œì íŠ¸ ì½”ë”© ê°€ì´ë“œë¼ì¸

## ğŸ“‹ ê¸°ë³¸ ì›ì¹™

### 1. ì£¼ì„ ì‘ì„± ê·œì¹™
- **ëª¨ë“  ì£¼ì„ì€ ì˜ì–´ë¡œ ì‘ì„±**
- ì§ê´€ì ì´ê³  ëª…í™•í•œ ì„¤ëª… ì œê³µ
- í•¨ìˆ˜, êµ¬ì¡°ì²´, ì¤‘ìš”í•œ ë¡œì§ì— ì£¼ì„ í•„ìˆ˜

### 2. íŒ¨í‚¤ì§€ êµ¬ì¡° ê·œì¹™
```
internal/
â”œâ”€â”€ client/                 # ì™¸ë¶€ API í†µì‹  (HTTP, WebSocket)
â”œâ”€â”€ producer/               # Producer ë¡œì§ (ë¸”ë¡ ë™ê¸°í™”)
â”œâ”€â”€ consumer/               # Consumer ë¡œì§ (ì´ë²¤íŠ¸ ì²˜ë¦¬)
â”œâ”€â”€ types/                  # ê³µí†µ íƒ€ì… ì •ì˜
â”œâ”€â”€ service/                # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì„œë¹„ìŠ¤
â”œâ”€â”€ domain/                 # ë„ë©”ì¸ ëª¨ë¸
â”œâ”€â”€ repository/             # ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ
â”œâ”€â”€ queue/                  # ë©”ì‹œì§€ í ì²˜ë¦¬
â”œâ”€â”€ api/                    # API ê´€ë ¨
â””â”€â”€ config/                 # ì„¤ì • ê´€ë¦¬
```

### 3. MSA ì•„í‚¤í…ì²˜ íŒ¨í„´
- **Producer**: `client/` â†’ `producer/` â†’ `service/` â†’ `repository/`
- **Consumer**: `queue/` â†’ `consumer/` â†’ `service/` â†’ `repository/`
- **API**: `api/` â†’ `service/` â†’ `repository/`

## ğŸ—ï¸ ì½”ë“œ êµ¬ì¡° ê°€ì´ë“œë¼ì¸

### 1. íŒŒì¼ ë° íŒ¨í‚¤ì§€ ëª…ëª…
- **íŒŒì¼ëª…**: snake_case ì‚¬ìš© (ì˜ˆ: `event_parser.go`, `http_client.go`)
- **íŒ¨í‚¤ì§€ëª…**: ì†Œë¬¸ì ë‹¨ì¼ ë‹¨ì–´ ì‚¬ìš© (ì˜ˆ: `client`, `producer`, `consumer`)
- **êµ¬ì¡°ì²´ëª…**: PascalCase ì‚¬ìš© (ì˜ˆ: `SubscriptionClient`, `EventParser`)

### 2. í•¨ìˆ˜ ì‘ì„± ê·œì¹™
```go
// FunctionName performs a specific action
// Parameters: description of parameters
// Returns: description of return values
func FunctionName(ctx context.Context, param string) error {
    // Implementation with clear logic
    if err := doSomething(); err != nil {
        return fmt.Errorf("context: %w", err)
    }
    return nil
}
```

### 3. ì—ëŸ¬ ì²˜ë¦¬
- **í•­ìƒ ì—ëŸ¬ë¥¼ ì²´í¬í•˜ê³  ì ì ˆíˆ ì²˜ë¦¬**
- **fmt.Errorfë¡œ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì¶”ê°€**
- **ë¡œê·¸ ë©”ì‹œì§€ì™€ í•¨ê»˜ ì—ëŸ¬ ì •ë³´ ì œê³µ**

```go
if err := someOperation(); err != nil {
    log.Printf("operation failed: %v", err)
    return fmt.Errorf("operation failed: %w", err)
}
```

### 4. ë¡œê¹… ê·œì¹™
- **êµ¬ì¡°í™”ëœ ë¡œê·¸ ë©”ì‹œì§€ ì‚¬ìš©**
- **ì¤‘ìš”í•œ ë‹¨ê³„ë§ˆë‹¤ ë¡œê·¸ ì¶”ê°€**
- **ì—ëŸ¬ ìƒí™©ì—ì„œ ìƒì„¸í•œ ì •ë³´ ì œê³µ**

```go
log.Printf("ServiceName: starting operation for %s", identifier)
log.Printf("ServiceName: operation completed successfully")
log.Printf("ServiceName: operation failed: %v", err)
```

## ğŸ”§ íŠ¹ì • íŒ¨í‚¤ì§€ ê°€ì´ë“œë¼ì¸

### 1. Client íŒ¨í‚¤ì§€ (`internal/client/`)
- **HTTP/WebSocket í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„**
- **ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì¸í„°í˜ì´ìŠ¤ ì œê³µ**
- **ì—°ê²° ê´€ë¦¬ ë° ì—ëŸ¬ í•¸ë“¤ë§**

### 2. Producer íŒ¨í‚¤ì§€ (`internal/producer/`)
- **ë¸”ë¡ ë™ê¸°í™” í•µì‹¬ ë¡œì§**
- **ë°ì´í„° ìˆ˜ì§‘ ë° ì²˜ë¦¬**
- **ì‹¤ì‹œê°„ ë™ê¸°í™” ì§€ì›**

### 3. Consumer íŒ¨í‚¤ì§€ (`internal/consumer/`)
- **ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° íŒŒì‹±**
- **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„**
- **í ë©”ì‹œì§€ ì†Œë¹„**

### 4. Service íŒ¨í‚¤ì§€ (`internal/service/`)
- **ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ ì¡°í•©**
- **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜**
- **íŠ¸ëœì­ì…˜ ê´€ë¦¬**

### 5. Repository íŒ¨í‚¤ì§€ (`internal/repository/`)
- **ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ë¡œì§**
- **CRUD ì‘ì—… êµ¬í˜„**
- **ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥**

## ğŸ“ ì½”ë“œ ì˜ˆì‹œ

### 1. êµ¬ì¡°ì²´ ì •ì˜
```go
// ServiceName handles specific business logic
type ServiceName struct {
    client     *client.Client
    repository repository.Repository
    config     *config.Config
}

// NewServiceName creates a new service instance
func NewServiceName(client *client.Client, repo repository.Repository, cfg *config.Config) *ServiceName {
    return &ServiceName{
        client:     client,
        repository: repo,
        config:     cfg,
    }
}
```

### 2. ë©”ì„œë“œ êµ¬í˜„
```go
// ProcessData processes incoming data
func (s *ServiceName) ProcessData(ctx context.Context, data *domain.Data) error {
    log.Printf("ServiceName: processing data %s", data.ID)
    
    // Validate input
    if err := s.validateData(data); err != nil {
        return fmt.Errorf("validate data: %w", err)
    }
    
    // Process data
    if err := s.repository.Save(ctx, data); err != nil {
        return fmt.Errorf("save data: %w", err)
    }
    
    log.Printf("ServiceName: data %s processed successfully", data.ID)
    return nil
}
```

### 3. ì—ëŸ¬ ì²˜ë¦¬
```go
// HandleError handles errors with proper context
func (s *ServiceName) HandleError(err error, operation string) error {
    if err == nil {
        return nil
    }
    
    log.Printf("ServiceName: %s failed: %v", operation, err)
    return fmt.Errorf("%s: %w", operation, err)
}
```

## ğŸš€ ì„±ëŠ¥ ë° ì•ˆì •ì„± ê°€ì´ë“œë¼ì¸

### 1. ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©
- **ëª¨ë“  ì™¸ë¶€ í˜¸ì¶œì— context ì‚¬ìš©**
- **íƒ€ì„ì•„ì›ƒ ë° ì·¨ì†Œ ì²˜ë¦¬**
- **ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë³´ì¥**

### 2. ë™ì‹œì„± ì²˜ë¦¬
- **ê³ ë£¨í‹´ ì‚¬ìš© ì‹œ ì ì ˆí•œ ë™ê¸°í™”**
- **ì±„ë„ ì‚¬ìš©ìœ¼ë¡œ ì•ˆì „í•œ í†µì‹ **
- **ë°ë“œë½ ë°©ì§€**

### 3. ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
- **ì—°ê²° í’€ ì‚¬ìš©**
- **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€**
- **ì ì ˆí•œ ì •ë¦¬ ë¡œì§**

## ğŸ” ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ì£¼ì„ì´ ì˜ì–´ë¡œ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] ì—ëŸ¬ ì²˜ë¦¬ê°€ ì ì ˆí•œê°€?
- [ ] ë¡œê·¸ ë©”ì‹œì§€ê°€ ëª…í™•í•œê°€?
- [ ] íŒ¨í‚¤ì§€ êµ¬ì¡°ê°€ ì˜¬ë°”ë¥¸ê°€?
- [ ] í•¨ìˆ˜ëª…ì´ ëª…í™•í•œê°€?
- [ ] ì»¨í…ìŠ¤íŠ¸ê°€ ì ì ˆíˆ ì‚¬ìš©ë˜ì—ˆëŠ”ê°€?
- [ ] í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ìˆëŠ”ê°€?

## ğŸ“š ì°¸ê³  ìë£Œ

- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Effective Go](https://golang.org/doc/effective_go.html)
- [Go Best Practices](https://github.com/golang-standards/project-layout)

- ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬ëŠ” ì‹¤ì‹œê°„ ë™ê¸°í™”ê°€ ì•ˆì •í™”ëœ í›„ ì‹¤í–‰
- ë¬´ê²°ì„± ê²€ì‚¬ ê²°ê³¼ ëˆ„ë½ëœ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ ë³µêµ¬ë˜ì–´ ì™„ë²½í•œ ë°ì´í„°ì…‹ êµ¬ì„±